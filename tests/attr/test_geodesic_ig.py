import pytest
import torch as th

from contextlib import nullcontext

from tint.attr import GeodesicIntegratedGradients

from tests.basic_models import BasicModel, BasicModel5_MultiArgs


@pytest.mark.parametrize(
    ["forward_func", "nn", "data", "n_neighbors", "multiply_by_inputs", "fails"],
    [
        (BasicModel(), None, None, None, True, False),
        (BasicModel5_MultiArgs(), None, None, None, True, False),
        (BasicModel(), None, th.rand(8, 5, 3), 5, True, False),
        (BasicModel(), None, None, None, False, False),
    ],
)
def test_init(forward_func, nn, data, n_neighbors, multiply_by_inputs, fails):
    with pytest.raises(Exception) if fails else nullcontext():
        explainer = GeodesicIntegratedGradients(
            forward_func=forward_func,
            nn=nn,
            data=data,
            n_neighbors=n_neighbors,
            multiply_by_inputs=multiply_by_inputs,
        )
        assert isinstance(explainer, GeodesicIntegratedGradients)


@pytest.mark.parametrize(
    [
        "forward_func",
        "multiply_by_inputs",
        "inputs",
        "baselines",
        "target",
        "additional_forward_args",
        "n_neighbors",
        "n_steps",
        "n_steiner",
        "method",
        "internal_batch_size",
        "return_curvature",
        "return_convergence_delta",
        "distance",
        "show_progress",
        "fails",
    ],
    [
        (
            BasicModel(),
            True,
            th.rand(8, 5, 3),
            None,
            None,
            None,
            5,
            10,
            None,
            "gausslegendre",
            None,
            False,
            False,
            "geodesic",
            False,
            False,
        ),
        (
            BasicModel(),
            True,
            th.rand(8, 5, 3),
            0,
            None,
            None,
            5,
            10,
            None,
            "gausslegendre",
            None,
            False,
            False,
            "geodesic",
            False,
            False,
        ),
        (
            BasicModel(),
            True,
            th.rand(8, 5, 3),
            th.rand(8, 5, 3),
            None,
            None,
            5,
            10,
            None,
            "gausslegendre",
            None,
            False,
            False,
            "geodesic",
            False,
            False,
        ),
        (
            BasicModel(),
            True,
            th.rand(8, 5, 3),
            None,
            0,
            None,
            5,
            10,
            None,
            "gausslegendre",
            None,
            False,
            False,
            "geodesic",
            False,
            False,
        ),
        (
            BasicModel(),
            True,
            th.rand(8, 5, 3),
            None,
            None,
            None,
            5,
            10,
            2,
            "gausslegendre",
            None,
            False,
            False,
            "geodesic",
            False,
            False,
        ),
        (
            BasicModel(),
            True,
            th.rand(8, 5, 3),
            None,
            None,
            None,
            5,
            -1,
            None,
            "gausslegendre",
            None,
            False,
            False,
            "geodesic",
            False,
            True,
        ),
        (
            BasicModel(),
            True,
            th.rand(8, 5, 3),
            None,
            None,
            None,
            5,
            10,
            None,
            "riemann_trapezoid",
            None,
            False,
            False,
            "geodesic",
            False,
            False,
        ),
        (
            BasicModel(),
            True,
            th.rand(8, 5, 3),
            None,
            None,
            None,
            5,
            10,
            None,
            "gausslegendre",
            8,
            False,
            False,
            "geodesic",
            False,
            False,
        ),
        (
            BasicModel(),
            True,
            th.rand(8, 5, 3),
            None,
            None,
            None,
            5,
            10,
            None,
            "gausslegendre",
            None,
            True,
            False,
            "geodesic",
            False,
            False,
        ),
        (
            BasicModel(),
            True,
            th.rand(8, 5, 3),
            None,
            None,
            None,
            5,
            10,
            None,
            "gausslegendre",
            None,
            False,
            True,
            "geodesic",
            False,
            False,
        ),
        (
            BasicModel(),
            True,
            th.rand(8, 5, 3),
            None,
            None,
            None,
            5,
            10,
            None,
            "gausslegendre",
            None,
            True,
            True,
            "geodesic",
            False,
            False,
        ),
        (
            BasicModel(),
            True,
            th.rand(8, 5, 3),
            None,
            None,
            None,
            5,
            10,
            None,
            "gausslegendre",
            None,
            False,
            False,
            "euclidean",
            False,
            False,
        ),
        (
            BasicModel(),
            True,
            th.rand(8, 5, 3),
            None,
            None,
            None,
            5,
            10,
            None,
            "gausslegendre",
            None,
            False,
            False,
            "geodesic",
            True,
            False,
        ),
    ],
)
def test_time_forward_tunnel(
    forward_func,
    multiply_by_inputs,
    inputs,
    baselines,
    target,
    additional_forward_args,
    n_neighbors,
    n_steps,
    n_steiner,
    method,
    internal_batch_size,
    return_curvature,
    return_convergence_delta,
    distance,
    show_progress,
    fails,
):
    with pytest.raises(Exception) if fails else nullcontext():
        explainer = GeodesicIntegratedGradients(forward_func=forward_func, multiply_by_inputs=multiply_by_inputs)

        attr = explainer.attribute(
            inputs=inputs,
            baselines=baselines,
            target=target,
            additional_forward_args=additional_forward_args,
            n_neighbors=n_neighbors,
            n_steps=n_steps,
            n_steiner=n_steiner,
            method=method,
            internal_batch_size=internal_batch_size,
            return_curvature=return_curvature,
            return_convergence_delta=return_convergence_delta,
            distance=distance,
            show_progress=show_progress,
        )

        if return_convergence_delta:
            if return_curvature:
                attr, delta, curvature = attr
                assert tuple(curvature.shape) == (8,)
                assert all(curvature >= 0.0)
                assert tuple(delta.shape) == (8,)
            else:
                attr, delta = attr
                assert tuple(delta.shape) == (8,)
        else:
            if return_curvature:
                attr, curvature = attr
                assert tuple(curvature.shape) == (8,)
                assert all(curvature >= 0.0)

        assert attr.shape == inputs.shape
